
# Exception Handling

Exception handling is a way of dealing with errors that occur during program execution,so the program doesn't crash unexpectedly

#### try
- The try block lets you test a block of code for errors.

```
try:

    print(x)

except:

    print("An error occured")
```
#### except
- The except block lets you handle the error.

```
try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong")

```
#### else
- The else block lets you execute code when there is no error.

```

try:

    print("hello")

except NameError:

    print("Variable is not defined")

else:

    print("No error occured")


```
#### finally
- The finally block lets you execute code, regardless of the result of the try- and except blocks.

```
try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished")

```

```
try:

    n=0

    res=100/n

except ZeroDivisionError:

    print("Can't divide with zero")


except ValueError:

    print("Enter a valid number")

else:

    print("result is ", res)

finally:

    print("Execution completes")
```
### Raise an exception

We can chose to throw an exception if a condition occurs
so that we use **raise** keyword

```
x = "hello"

if not type(x) is int:
  raise TypeError("Only integers are allowed")
```

### custom exception

You can define your own exception types by creating a new class that inherits from Exception.

```
class Above_age(Exception):

    pass
    
x=26

try:
    if x>18:
        raise Above_age("Above 18years old")

except Above_age as e:

    print("find exception",e)
``` 

```
class ShortPasswordError(Exception):
    pass

password = "sdwd"

try:
    if len(password) < 6:
        raise ShortPasswordError("password must be at least 6 characters long")
    else:
        print("password accepted")
except ShortPasswordError as e:
    print("Error:", e)

```

# Types of error

1. SyntaxError

Occurs when Python code has incorrect syntax

2. NameError

Occurs when a variable is not defines

3. TypeError

Occurs when an operation is applied to an object of inappropriate type.

4. ValueError

Occurs when the type is correct but the value is inappropriate.

5. IndexError

Occurs when accessing an index that doesn't exist in a list or string.

6. KeyError

Occurs when accessing a non-existent key in a dictionary.

7. AttributeError

Occurs when calling an invalid method or attribute.

8. ZeroDivisionError

Occurs when dividing by zero.

9. ImportError / ModuleNotFoundError

Occurs when importing a module or object that doesnâ€™t exist.

10. IndentationError

Occurs when the indentation of code is incorrect.


11. OverflowError

Occurs when the result of a calculation is too large.

12. MemoryError

Occurs when Python runs out of memory.

# Decorators

In python decorators is a powerfull tool to modify or extend the behaviour of functions or methods,without changing their actual code.

A decorator is essentially a function that takes another function as an argument and returns with enhanced
functionality.


```
def decorator_function(org_function):

    def wrapper_function():

        print("Something before the function runs")

        org_function()

        print("Something after the function runs")

    return wrapper_function

@decorator_function
def say_hello():

    print("hello")

say_hello()
```
```
def decorator(func):
  
    def wrapper():
        print("Before calling the function.")
        func()
        print("After calling the function.")
    return wrapper

# Applying the decorator to a function
@decorator

def greet():
    print("Hello, World!")

greet()

```

# Scope in a class

**Local scope** - A class or variable defined inside a function or method is only accessible within the that block

```
def outer_function():

    message="I'm a local variable"

    class LocalCLass:

        def show(self):

            print(message)

    
    obj_instance=LocalCLass()

    obj_instance.show()

outer_function()

```

**Global scope** - When you define a class or variable outside the function ,it's in the global scope --meaning it can be accessed anywhere in your program

```
message="I'm a global variable"

class MyClass:

    def show(self):

        print(message)

obj=MyClass()

obj.show()
```

