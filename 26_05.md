

# Python Collections

The collection module in Python provides different types of containers. A Container is an object that is used to store different objects and provide a way to access the contained objects and iterate over them.
Some of the built-in containers are Tuple,List,Dictionary etc.

Different types of containers are:-
    -Counters
    -OrderedDict
    -DefaultDict
    -ChainMap
    -NamedTuple
    -Deque
    -UserDict
    -UserList
    -UserString

### Counters
A Counter is a subclass of dict that counts the occurrences of elements in an iterable.

In the form of an unordered dictionary where the key represents the element in the iterable and value represents the count of that element in the iterable.

Note: It is equivalent to bag or multiset of other languages.

Syntax:class collections.Counter   ([iterable-or-mapping])

```
from collections import Counter

c=Counter("banana")

print(c)
```

### OrderedDict

An OrderedDict is also a sub-class of dictionary but unlike dictionary, it remembers the order in which the keys were inserted. 

Syntax:class collections.OrderDict()

```
from collections import OrderedDict

od = OrderedDict()
od['a'] = 1
od['b'] = 2
print(od)  # Output: OrderedDict([('a', 1), ('b', 2)])
```
### DefaultDict

A DefaultDict is also a sub-class to dictionary. It is used to provide some default values for the key 
that does not exist and never raises a KeyError.

Syntax:class collections.defaultdict(default_factory)

```
from collections import defaultdict

dd = defaultdict(int)
dd['a'] = 1
print(dd)  
```
### ChainMap

A ChainMap groups multiple dictionaries into a single unit and returns a list of dictionaries.

Syntax:class collections.ChainMap(dict1, dict2)

```
from collections import ChainMap

dict1 = {'a': 1}
dict2 = {'b': 2}
cm = ChainMap(dict1, dict2)
print(cm)  # Output: ChainMap({'a': 1}, {'b': 2})

```
### NamedTuple

A namedtuple is like a regular tuple but with named fields, allowing access by attribute instead of only index.

Syntax:class collections.namedtuple(typename, field_names)

```
from collections import namedtuple

Student = namedtuple('Student', ['fname', 'lname', 'dob'])
s = Student('John', 'Doe', '2000-01-01')
print(s.fname)  # Output: John

```

### Deque

A deque allows fast appends/pops from both ends (O(1) complexity).

Syntax:class collections.deque(list)

```
from collections import deque

dq=deque([1,2,3])

dq.append(4)

dq.appendleft(3)

print(dq)   #output:-deque([3, 1, 2, 3, 4])

```
### UserDict

UserDict is a dictionary-like container that acts as a wrapper around the dictionary objects. This container is used when someone wants to create their own dictionary with some modified or new functionality. 

Syntax:class collections.UserDict([initialdata])

### UserList

UserList is a list like container that acts as a wrapper around the list objects. This is useful when someone wants to create their own list with some modified or additional functionality.

Syntax:class collections.UserList([list])

### UserString

UserString is a string like container and just like UserDict and UserList it acts as a wrapper around string objects. It is used when someone wants to create their own strings with some modified or additional functionality. 

Syntax:class collections.UserString(seq)

## Type Hint

Specifies the expected data type of parameters (used for clarity, tools, and linters â€” but not enforced at runtime).

```
def greet(name: str):
    print(f"Hello, {name}")

```
This tells Python (and developers) that name should be a str.

# Lambda Functions (Anonymous)

A lambda function is a small anonymous function.

A lambda function can take any number of arguments, but can only have one expression.


square = lambda x: x * x
square(5)  # 25
ðŸ§ª Built-in vs User-defined
Built-in: len(), print(), type(), etc.